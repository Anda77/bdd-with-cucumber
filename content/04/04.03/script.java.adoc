include::./title.adoc[]

shot::[???]

After the feature keyword, we have space in a Gherkin document to write any arbitrary text that we like. We call this the feature’s description. This is a great place to write up any notes or other details that can’t easily be expressed in examples. You might have links to wiki pages or issue trackers, or to wireframes. You can put anything you like in here, as long as you don’t mention the magic word scenario.

Something we really like to put into the description are the acceptance criteria or business rules we’re trying to implement. In this case, we can explain that, for the time being, we’re broadcasting to all users, irrespective of distance.

[writes out list of rules]
shot::[???]

Because we know we’ll need to filter by proximity - later - we can also write a todo list here so it’s clear that we do intend to get to that soon.

[writes out todo list]
shot::[???]

Changing the description doesn’t change anything about how Cucumber will run this feature. It just helps the human beings reading this document to understand more of what you understand about the system you’re building.

The step “Given Lucy is 15m from Sean” is misleading, since the distance between the two people is not yet relevant in our current model.

[shows move_to method in Person class]
shot::[???]

We have this code here, a move to method on Person, that’s being called from the step definition but doesn’t actually do anything.

Let’s simplify this code to do just what it needs to do right now, and no more. We can start from the scenario by changing this single step to express what’s actually going on. We’ll work on one scenario at a time, and update the other one once we’re happy with this one.

.hear_shout.feature
[source,gherkin]
----
Scenario: Listener is within range
  Given a person named Lucy
  And a person named Sean
  When Sean shouts "Free bagels!"
  Then Lucy hears Sean's message
----

Now we have two steps, each creating a person. Notice we’re starting to reveal some more of our domain language here: we’ve introduced the words Person and name. Person is already a part of our domain language, so it’s nice to have that revealed in the language of the scenario. Name may well become an attribute of our person soon, so it’s also useful to have that surfaced so we can get feedback about it from the team.

One thing we’ve lost by doing this is the idea that, eventually, the two people will need to be close to each other for the message to be transmitted. We definitely wouldn’t remove detail like that unilaterally, without discussing it with the other people who were in the three amigos meeting with us when the example was written. In this case, as well as adding it to the TODO list above, we’ve decided to update the names of the existing scenarios, and write a couple of new empty scenarios to remind us to implement that behaviour later.

[renames first scenario, writes out two new empty scenarios for in / out of range]
shot::[???]

Now the scenario names make sense, and we’ve got a reminder of future scenarios we’ll need to implement. Let’s press on.

We can run Cucumber to generate new step definition snippets for the new steps:

[runs cucumber]
shot::[???]

and paste them into our steps file.

Now to implement these two separate steps we have a bit of a problem. We need the same instance of Network available in both. We could just assume that the Lucy step will always run first and create it there, but that seems fragile. If someone wrote a new scenario that didn’t create people in the right order, they’d end up with no Network instance, and weird bugs. We want our steps to be as independent as possible, so they can be easily composed into new scenarios.
