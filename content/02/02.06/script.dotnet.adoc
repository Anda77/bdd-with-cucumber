include::./title.adoc[]

////
Overview:
* Make a simple implementation of GetMessagesHeard with hard-coded message
* Add a new scenario to prove the incorrectness of our implementation
////


// *** Make a simple implementation of GetMessagesHeard with hard-coded message ***

So we have our failing scenario: shot::[1]

[source,bash]
----
Given Lucy is located 15m from Sean
-> done: StepDefinitions.GivenLucyIsLocatedMFromSean(15) (0.0s)
When Sean shouts "free bagels at Sean's"
-> done: StepDefinitions.WhenSeanShouts("free bagels at Se...") (0.0s)
Then Lucy hears Sean's message
-> error: Value cannot be null. (Parameter 'collection')
----

Lucy is expected to hear Sean's message, but she hasn't heard anything: we got `null` back from the `GetMessagesHeard` method. shot::[2]

In this case, we're going to cheat. We have a one-line fix that will make this scenario pass, but it's not a particularly future-proof implementation. Can you guess what it is? shot::[3]

[source,csharp]
----
public IList<string> GetMessagesHeard()
{
    return new List<string> { "free bagels at Sean's" };
}
----

I told you it wasn't very future proof! But let's see what SpecFlow says to that.

shot::[4]

Fantastic! Our scenario is passing for the first time. As long as this is the _only_ message anyone ever shouts, we're good to ship this thing! But I'm afraid this is not going to be the case so let's work a bit more on it.



// *** Add a new scenario to prove the incorrectness of our implementation ***

Now, the fact that such a poor implementation can pass our _all_ tests shows us that we need to work on our tests. A more comprehensive set of tests would guide us towards a better implementation.

It's also a good habit to look for the most simple solution. We can trust that, as our tests evolve, so will our solution.

This is the essence of Behaviour-Driven Development. Examples of behaviour drive the development. We do just enough to make the next test pass, and no more.

Instead of writing a note on our TODO list, let's write another test that shouts a different message. Usually we'd expect a developer to do this using a unit test, but to keep things simple, we're going to write another scenario. shot::[5]

We've worked hard. It's time for a coffee, so let's come up with an example that has Sean offering free coffee. shot::[5]

[source,gherkin]
----
Feature: Hear shout
  Scenario: Listener is within range
    Given Lucy is located 15m from Sean
    When Sean shouts "free bagels at Sean's"
    Then Lucy hears Sean's message

  Scenario: Listener hears a different message
    Given Lucy is located 15m from Sean
    When Sean shouts "Free coffee!"
    Then Lucy hears Sean's message
----

It fails, reminding us we need to find a solution that doesn't rely on hard-coding the message. shot::[6]
Now when we come back to this code, we can just run the tests and SpecFlow will remind us what we need to do next. We're done for today!

[source,bash]
----
Test Name:	Listener hears a different message
[...]
Result Message:
Assert.Contains() Failure
Not found: Free coffee!
In value:  List<String> ["free bagels at Sean's"]
Result StandardOutput:
Given Lucy is located 15m from Sean
-> done: StepDefinitions.GivenLucyIsLocatedMFromSean(15) (0.0s)
When Sean shouts "Free coffee!"
-> done: StepDefinitions.WhenSeanShouts("Free coffee!") (0.0s)
Then Lucy hears Sean's message
-> error: Assert.Contains() Failure
Not found: Free coffee!
In value:  List<String> ["free bagels at Sean's"]
----

Of course, if you're in the mood, you can always try to implement a solution yourself that makes both scenarios pass. Have fun!
