include::./title.adoc[]

////
Overview: 
* Make a simple implementation of GetMessagesHeard with hard-coded message
* Add a new scenario to prove the incorrectness of our implementation
////


// *** Make a simple implementation of GetMessagesHeard with hard-coded message ***

So we have our failing scenario: shot::[1]

[source,bash]
----
Given Lucy is located 15m from Sean
-> done: StepDefinitions.GivenLucyIsLocatedMFromSean(15) (0.0s)
When Sean shouts "free bagels at Sean's"
-> done: StepDefinitions.WhenSeanShouts("free bagels at Se...") (0.0s)
Then Lucy hears Sean's message
-> error: Value cannot be null. (Parameter 'collection')
----

Lucy is expected to hear Sean's message, but she hasn't heard anything: we got `null` back from the `GetMessagesHeard` method. shot::[2]

In this case, we're going to cheat. We have a one-line fix that will make this scenario pass, but it's not a particularly future-proof implementation. Can you guess what it is? shot::[3]

[source,csharp]
----
public IList<string> GetMessagesHeard()
{
    return new List<string> { "free bagels at Sean's" };
}
----

I told you it wasn't very future proof! But let's see what SpecFlow says to that.

shot::[4]

Fantastic! Our scenario is passing for the first time. As long as this is the _only_ message anyone ever shouts, we're good to ship this thing! But I'm afraid this is not going to be the case so let's work a bit more on it.



// *** Add a new scenario to prove the incorrectness of our implementation ***

Now, the fact that such a poor implementation can pass _all_ our tests shows us that we need to work on our tests. 

The scenario has shown an illustrative example to help us understanding the requirements. In our case the problem is not about the understanding of the requirements anymore but the implementation quality, that can be ensured the best with a programmer test, like a unit test. So probably this is what you would do now. In a later chapter we will discuss more in detail, how the different test types can address different aspects of the quality. But for now, let's assume we wanted Shouty to work only with this particular message. If this was the case we are good with our implementation for now. 

But we don't want to stop here, but would like to further discover how Shouty should work. Now we would like to support any arbitrary message and to illustrate that we could come up with another scenario that shouts a different message and try to satisfy that. 

This is the essence of Behaviour-Driven Development. Examples of behaviour drive the development. We do just enough to make the next scenario pass, and no more.

We worked a lot. It's time for a coffee, so let's come up with an example when Sean offers free coffee. shot::[5]

[source,gherkin]
----
Feature: Hear shout
  Scenario: Listener is within range
    Given Lucy is located 15m from Sean
    When Sean shouts "free bagels at Sean's"
    Then Lucy hears Sean's message

  Scenario: Listener hears a different message
    Given Lucy is located 15m from Sean
    When Sean shouts "Free coffee!"
    Then Lucy hears Sean's message
----

It fails, reminding us we need to find a solution that doesn't rely on hard-coding the message. shot::[6]
Now when we come back to this code, we can just run the tests and SpecFlow will remind us what we need to do next. We're done for today!

[source,bash]
----
Test Name:	Listener hears a different message
[...]
Result Message:	
Assert.Contains() Failure
Not found: Free coffee!
In value:  List<String> ["free bagels at Sean's"]
Result StandardOutput:	
Given Lucy is located 15m from Sean
-> done: StepDefinitions.GivenLucyIsLocatedMFromSean(15) (0.0s)
When Sean shouts "Free coffee!"
-> done: StepDefinitions.WhenSeanShouts("Free coffee!") (0.0s)
Then Lucy hears Sean's message
-> error: Assert.Contains() Failure
Not found: Free coffee!
In value:  List<String> ["free bagels at Sean's"]
----

Of course, if you're in the mood, you can always try to implement a solution yourself that makes both scenarios pass. Have fun!
