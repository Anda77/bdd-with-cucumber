include::./title.adoc[]

Let's look at the two scenarios that illustrate the rule about range again. We’re using two different listeners, Lucy, who’s within range, and Larry, who’s not. It’s always Sean who’s doing the shouting.

Notice that we also specify the range in each scenario. We could have just hard-coded it within the system, but having it documented here helps to make the behaviour we’ve specified much easier to understand.

A happy side-effect is that, in order to set the range from our scenario, we’ve had to make it a configurable property of the system. So if our business stakeholders ever change their minds about the range, we won’t have to go hunting around in the code for where we’d hard-coded it.

Notice how the steps that create the Sean, Lucy, and Larry are very similar.

When we see steps like this, Gherkin’s Given When Then syntax starts to feel a bit clunky. Imagine if we could just write out a table, like this:

 And the following people:
      | name  | location |
      | Lucy  |      100 |
      | Sean  |        0 |

Well, we’re in luck. You can!

Gherkin has a special syntax called Data Tables, that allows you to specify tabular data for a step, using pipe characters to mark the boundary between cells.

As you can see, the step definition implicitly takes a single argument, which as this comment explains is a <ruby>Cucumber::Ast::DataTable</ruby> <java>cucumber.api.DataTable</java>. This object has a rich API for using the tabular data.

At its most basic, the table is just a two-dimensional array of arrays:

shot::["System.out.println(table.raw());"]

shot::[run Cucumber]

You can also turn the table into a List of Map, where the first row is used for the map keys, and each following row is used for the map values.

shot::[System.out.println(table.asMaps(String.class, String.class));]

shot::[run cucumber]

shot::[]
Now we can easily iterate over these maps and turn them into instances of Person:

shot::[run cucumber]

shot::[delete unused step def]
With that done, we can delete our old step definition, which is now unused.



Cucumber strips all the white space surrounding each cell, so we can have a nice neat table in the Gherkin but still get clean values in the step definition underneath.

Notice we’ve still had to convert the location from a string to an integer, because Cucumber can’t know that’s the type of value in our table.

If you have a class that has the same field names as the header row in the table, you can have Cucumber automatically convert the table into a list of that class. If our Person object had name and location fields, and didn’t take an instance of Network in its constructor, we could automatically create instances of Person from this table.

But things aren’t always that simple.

Instead, we’ll define a simple Whereabouts class to represent the data in the table.

shot::[creates the class]

We’ve made it an inner class to the step definition class, as it doesn’t form part of our core domain.

Now we can use the asList method on the DataTable to convert the table into a list of Whereabouts.

shot::[changes the code]

In fact, you don’t have to explicitly convert the table to a list. If you declare your table parameter as a generic list, Cucumber will automatically convert the table into a list of the generic type for you.

shot::[changes the code again]
