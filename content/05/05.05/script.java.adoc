include::./title.adoc[]

When writing scenarios, occasionally we want to use a really long piece of data.

For example, let’s introduce a new rule about the maximum length of a message shot::[]

.hear_shout.feature
[source,gherkin]
----
include::../code/java/17-Max length rule/shouty/src/test/resources/shouty/hear_shout.feature[lines=40..40]
----

...and add a scenario to illustrate it shot::[], making the string just over the boundary of the rule:

[source,gherkin]
----
include::../code/java/17-Max length rule/shouty/src/test/resources/shouty/hear_shout.feature[lines=40..40]
----

That’s pretty ugly isn’t it!

Still, we’ll press on and get it to green, then we’ll show you how to clean it up.

shot::[mvn test] Our existing step definition handles that ugly step with the long message just fine, but the last outcome step is undefined. We could either add a new step definition, or paramterise "Larry should not hear a shout". Let's modify the existing step definition shot::[]

.StepDefinitions.java
[source,java]
----
include::../code/java/18-Parameterise stepdef/shouty/src/test/java/shouty/StepDefinitions.java[lines=87..90]
----

shot::[runs cucumber]

OK, so we have a failing acceptance test. Let’s dive down into our solution and implement this new rule. It seems like the Network should be responsible for implementing this rule, so let’s go to its unit tests and add a new example to specify this extra responsibility.

We’ll create a 181-character message like this shot::[] and then assert that the message should not be heard when it’s broadcast.

.NetworkTest.java
[source,java]
----
include::../code/java/19-Add test to NetworkTest/shouty/src/test/java/shouty/NetworkTest.java[lines=49..62]
----

Let’s run that test shot::[mvn test - show the unit test results]. Good, it fails. Lucy’s still getting the message at the moment. Now how are we going to implement this?

It looks like we’re already implementing the proximity rule here shot::[] in the broadcast method. Let’s add another if statement here about the message length.

.Network.java
[source,java]
----
include::../code/java/20-Implement maximum length/shouty/src/main/java/shouty/Network.java[lines=21..23]
----

shot::[mvn test] Run the unit test again… and it’s passing. Great.

The code here has got a little bit messy and hard to read. One very basic move we could make to improve it would be to just extract a couple of temporary variables.

.Network.java
[source,java]
----
include::../code/java/21-Tidy up Network logic/shouty/src/main/java/shouty/Network.java[lines=20..24]
----

That’s better. This code could be improved even further of course, but at least we haven’t made it any worse.

shot::[mvn test] Let’s just run the tests to check. Great - everything’s still green.

Now we have everything passing again, we can tidy up the Gherkin to use a new piece of syntax we’ve been wanting to tell you about: a DocString.

DocStrings allow you to specify a text argument for a step that spans over multiple lines. We could change our step to look like this instead:

[source,gherkin]
----
include::../code/java/22-DocString/shouty/src/test/resources/shouty/hear_shout.feature[lines=40..40]
----

Now the scenario is much more readable.

We have to add a new step definition too shot::[]. It doesn't need a parameter in the Cucumber Expression -- the DocString gets passed as a string argument to the step definition automatically.

.StepDefinitions.java
[source,java]
----
include::../code/java/22-DocString/shouty/src/test/java/shouty/StepDefinitions.java[lines=77..82]
----

Let's check that we're still green shot::[mvn test] -- and we are!

We don’t use DocStrings very often - having such a lot of data in a test can often make it quite brittle. But when you do need it, it's useful to know about.
